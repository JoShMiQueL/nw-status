name: Version Bump & Release

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version bump type (leave as "auto" to detect from commits)'
        required: true
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
          - prerelease
        default: 'auto'
      prerelease_suffix:
        description: 'Pre-release suffix (e.g., "alpha.1", "beta.2", "rc.1"). Leave empty for stable release.'
        required: false
        type: string
        default: ''

jobs:
  version-and-release:
    name: Bump Version and Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.3.0

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Validate prerelease suffix
        run: |
          CURRENT_BRANCH="${{ github.ref_name }}"
          PRERELEASE_SUFFIX="${{ inputs.prerelease_suffix }}"
          
          echo "Current branch: $CURRENT_BRANCH"
          echo "Prerelease suffix: $PRERELEASE_SUFFIX"
          
          # If not on main, prerelease suffix is REQUIRED
          if [ "$CURRENT_BRANCH" != "main" ]; then
            if [ -z "$PRERELEASE_SUFFIX" ]; then
              echo "❌ ERROR: Pre-release suffix is required when running from non-main branches"
              echo "Please provide a suffix like: alpha.1, beta.1, rc.1"
              echo "Current branch: $CURRENT_BRANCH"
              exit 1
            fi
            
            # Validate suffix format (must start with alpha, beta, or rc)
            if ! echo "$PRERELEASE_SUFFIX" | grep -qE '^(alpha|beta|rc)\.[0-9]+$'; then
              echo "❌ ERROR: Invalid pre-release suffix format"
              echo "Expected format: alpha.N, beta.N, or rc.N (e.g., alpha.1, beta.2, rc.1)"
              echo "Got: $PRERELEASE_SUFFIX"
              exit 1
            fi
            
            echo "✅ Valid pre-release suffix for branch $CURRENT_BRANCH"
          else
            # On main, suffix is optional (allows both stable and pre-releases from main)
            if [ -n "$PRERELEASE_SUFFIX" ]; then
              echo "⚠️ Creating pre-release from main branch with suffix: $PRERELEASE_SUFFIX"
            else
              echo "✅ Creating stable release from main branch"
            fi
          fi

      - name: Get current version
        id: current_version
        run: |
          CURRENT_VERSION=$(bun pm pkg get version | tr -d '"')
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Determine bump type
        id: determine_bump
        run: |
          BUMP_TYPE="${{ inputs.bump_type }}"
          
          if [ "$BUMP_TYPE" = "auto" ]; then
            echo "🔍 Analyzing commits to determine bump type..."
            
            # Get commits since last tag
            PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            
            if [ -z "$PREV_TAG" ]; then
              COMMITS=$(git log --pretty=format:"%s" --no-merges)
            else
              COMMITS=$(git log ${PREV_TAG}..HEAD --pretty=format:"%s" --no-merges)
            fi
            
            # Check for breaking changes (BREAKING CHANGE: or !)
            if echo "$COMMITS" | grep -qE "^[a-z]+(\(.+\))?!:|BREAKING CHANGE:"; then
              BUMP_TYPE="major"
              echo "🚨 Breaking changes detected → MAJOR bump"
            # Check for new features (feat:)
            elif echo "$COMMITS" | grep -qE "^feat(\(.+\))?:"; then
              BUMP_TYPE="minor"
              echo "✨ New features detected → MINOR bump"
            # Default to patch for fixes and other changes
            else
              BUMP_TYPE="patch"
              echo "🔧 Fixes/chores detected → PATCH bump"
            fi
          else
            echo "📌 Manual bump type selected: $BUMP_TYPE"
          fi
          
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "Final bump type: $BUMP_TYPE"

      - name: Check if tag exists
        id: check_tag
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.version }}"
          if git rev-parse "v$CURRENT_VERSION" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Tag v$CURRENT_VERSION already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Tag v$CURRENT_VERSION does not exist"
          fi

      - name: Bump version if tag exists
        if: steps.check_tag.outputs.exists == 'true'
        run: |
          echo "Tag already exists, bumping version..."
          CURRENT_VERSION="${{ steps.current_version.outputs.version }}"
          PRERELEASE_SUFFIX="${{ inputs.prerelease_suffix }}"
          
          # Remove any existing prerelease suffix from current version
          BASE_VERSION=$(echo "$CURRENT_VERSION" | sed 's/-.*$//')
          
          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"
          
          # Bump based on type
          case "${{ steps.determine_bump.outputs.bump_type }}" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          
          # Add prerelease suffix if provided
          if [ -n "$PRERELEASE_SUFFIX" ]; then
            NEW_VERSION="$NEW_VERSION-$PRERELEASE_SUFFIX"
            echo "Bumping from v$CURRENT_VERSION to v$NEW_VERSION (pre-release)"
          else
            echo "Bumping from v$CURRENT_VERSION to v$NEW_VERSION"
          fi
          
          # Update package.json
          bun pm pkg set version="$NEW_VERSION"
          
          # Commit and tag
          git add package.json
          git commit -m "chore: bump version to $NEW_VERSION"
          git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"

      - name: Create tag if doesn't exist
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.version }}"
          PRERELEASE_SUFFIX="${{ inputs.prerelease_suffix }}"
          
          # Add prerelease suffix if provided
          if [ -n "$PRERELEASE_SUFFIX" ]; then
            TAG_VERSION="$CURRENT_VERSION-$PRERELEASE_SUFFIX"
            echo "Creating tag for version v$TAG_VERSION (pre-release)"
            
            # Update package.json with suffix
            bun pm pkg set version="$TAG_VERSION"
            git add package.json
            git commit -m "chore: bump version to $TAG_VERSION"
          else
            TAG_VERSION="$CURRENT_VERSION"
            echo "Creating tag for existing version v$TAG_VERSION"
          fi
          
          git tag -a "v$TAG_VERSION" -m "Release v$TAG_VERSION"

      - name: Get final version
        id: final_version
        run: |
          FINAL_VERSION=$(bun pm pkg get version | tr -d '"')
          echo "version=$FINAL_VERSION" >> $GITHUB_OUTPUT
          echo "Final version: $FINAL_VERSION"

      - name: Push changes to new branch and create PR
        run: |
          VERSION="${{ steps.final_version.outputs.version }}"
          BRANCH_NAME="release/v$VERSION"
          
          # Create and push branch with tags
          git checkout -b "$BRANCH_NAME"
          git push origin "$BRANCH_NAME" --follow-tags
          
          # Create PR using GitHub API (targets the branch where workflow was run)
          curl -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ github.repository }}/pulls \
            -d "{
              \"title\": \"chore: release v$VERSION\",
              \"body\": \"## 🚀 Release v$VERSION\n\nThis PR was automatically created by the version bump workflow.\n\n### Changes\n- Bumped version to v$VERSION\n- Created tag v$VERSION\n\n**Please review and merge to trigger the release process.**\",
              \"head\": \"$BRANCH_NAME\",
              \"base\": \"${{ github.ref_name }}\"
            }"
        id: push_and_pr

      - name: Cleanup on failure
        if: failure()
        run: |
          VERSION="${{ steps.final_version.outputs.version }}"
          BRANCH="release/v$VERSION"
          
          echo "🧹 Cleaning up after failure..."
          
          # Delete local tag if it exists
          if git rev-parse "v$VERSION" >/dev/null 2>&1; then
            echo "Deleting local tag v$VERSION"
            git tag -d "v$VERSION"
          fi
          
          # Delete remote tag if it exists
          if git ls-remote --tags origin | grep -q "refs/tags/v$VERSION"; then
            echo "Deleting remote tag v$VERSION"
            git push origin ":refs/tags/v$VERSION" || true
          fi
          
          # Delete remote branch if it exists
          if git ls-remote --heads origin | grep -q "refs/heads/$BRANCH"; then
            echo "Deleting remote branch $BRANCH"
            git push origin ":$BRANCH" || true
          fi
          
          echo "✅ Cleanup completed"
