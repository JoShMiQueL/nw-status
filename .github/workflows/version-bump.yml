name: Version Bump & Release

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version bump type (leave as "auto" to detect from commits)'
        required: true
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
          - prerelease
        default: 'auto'
      target_branch:
        description: 'Target branch for the PR'
        required: true
        type: string
        default: 'main'

jobs:
  version-and-release:
    name: Bump Version and Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.3.0

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get current version
        id: current_version
        run: |
          CURRENT_VERSION=$(bun pm pkg get version | tr -d '"')
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Determine bump type
        id: determine_bump
        run: |
          BUMP_TYPE="${{ inputs.bump_type }}"
          
          if [ "$BUMP_TYPE" = "auto" ]; then
            echo "🔍 Analyzing commits to determine bump type..."
            
            # Get commits since last tag
            PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            
            if [ -z "$PREV_TAG" ]; then
              COMMITS=$(git log --pretty=format:"%s" --no-merges)
            else
              COMMITS=$(git log ${PREV_TAG}..HEAD --pretty=format:"%s" --no-merges)
            fi
            
            # Check for breaking changes (BREAKING CHANGE: or !)
            if echo "$COMMITS" | grep -qE "^[a-z]+(\(.+\))?!:|BREAKING CHANGE:"; then
              BUMP_TYPE="major"
              echo "🚨 Breaking changes detected → MAJOR bump"
            # Check for new features (feat:)
            elif echo "$COMMITS" | grep -qE "^feat(\(.+\))?:"; then
              BUMP_TYPE="minor"
              echo "✨ New features detected → MINOR bump"
            # Default to patch for fixes and other changes
            else
              BUMP_TYPE="patch"
              echo "🔧 Fixes/chores detected → PATCH bump"
            fi
          else
            echo "📌 Manual bump type selected: $BUMP_TYPE"
          fi
          
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "Final bump type: $BUMP_TYPE"

      - name: Check if tag exists
        id: check_tag
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.version }}"
          if git rev-parse "v$CURRENT_VERSION" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Tag v$CURRENT_VERSION already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Tag v$CURRENT_VERSION does not exist"
          fi

      - name: Bump version if tag exists
        if: steps.check_tag.outputs.exists == 'true'
        run: |
          echo "Tag already exists, bumping version..."
          CURRENT_VERSION="${{ steps.current_version.outputs.version }}"
          
          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Bump based on type
          case "${{ steps.determine_bump.outputs.bump_type }}" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "Bumping from v$CURRENT_VERSION to v$NEW_VERSION"
          
          # Update package.json
          bun pm pkg set version="$NEW_VERSION"
          
          # Commit and tag
          git add package.json
          git commit -m "chore: bump version to $NEW_VERSION"
          git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"

      - name: Create tag if doesn't exist
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.version }}"
          echo "Creating tag for existing version v$CURRENT_VERSION"
          git tag -a "v$CURRENT_VERSION" -m "Release v$CURRENT_VERSION"

      - name: Get final version
        id: final_version
        run: |
          FINAL_VERSION=$(bun pm pkg get version | tr -d '"')
          echo "version=$FINAL_VERSION" >> $GITHUB_OUTPUT
          echo "Final version: $FINAL_VERSION"

      - name: Push changes to new branch and create PR
        run: |
          VERSION="${{ steps.final_version.outputs.version }}"
          BRANCH_NAME="release/v$VERSION"
          
          # Create and push branch with tags
          git checkout -b "$BRANCH_NAME"
          git push origin "$BRANCH_NAME" --follow-tags
          
          # Create PR using GitHub API
          curl -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ github.repository }}/pulls \
            -d "{
              \"title\": \"chore: release v$VERSION\",
              \"body\": \"## 🚀 Release v$VERSION\n\nThis PR was automatically created by the version bump workflow.\n\n### Changes\n- Bumped version to v$VERSION\n- Created tag v$VERSION\n\n**Please review and merge to trigger the release process.**\",
              \"head\": \"$BRANCH_NAME\",
              \"base\": \"${{ inputs.target_branch }}\"
            }"
        id: push_and_pr

      - name: Cleanup on failure
        if: failure()
        run: |
          VERSION="${{ steps.final_version.outputs.version }}"
          BRANCH="release/v$VERSION"
          
          echo "🧹 Cleaning up after failure..."
          
          # Delete local tag if it exists
          if git rev-parse "v$VERSION" >/dev/null 2>&1; then
            echo "Deleting local tag v$VERSION"
            git tag -d "v$VERSION"
          fi
          
          # Delete remote tag if it exists
          if git ls-remote --tags origin | grep -q "refs/tags/v$VERSION"; then
            echo "Deleting remote tag v$VERSION"
            git push origin ":refs/tags/v$VERSION" || true
          fi
          
          # Delete remote branch if it exists
          if git ls-remote --heads origin | grep -q "refs/heads/$BRANCH"; then
            echo "Deleting remote branch $BRANCH"
            git push origin ":$BRANCH" || true
          fi
          
          echo "✅ Cleanup completed"
